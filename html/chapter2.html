<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第2章｜OSM 数据模型与 ODbL 合规（底层拓扑与法律边界）</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Nominatim & OpenStreetMap（OSM）导航 API 与 Navigation MCP 中文教程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章｜全景与快速上手（从 0 跑通一次 geocode + route）</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章｜OSM 数据模型与 ODbL 合规（底层拓扑与法律边界）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章｜OSM 数据获取、裁剪与增量更新（构建可持续的数据管道）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章｜PostGIS 与空间索引（地理查询的物理学）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章｜Nominatim 部署与核心 API（search / reverse / lookup）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章｜中文地址、POI 搜索与体验优化（让用户搜得到、搜得准）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章｜路由引擎选型与路网建模（OSRM / GraphHopper / Valhalla 怎么选）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章｜OSRM 实战：从 OSM 数据到路由服务（含 Match/Table/Trip）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章｜设计“面向业务”的 OSM 导航 API（把 Nominatim/OSRM 变成产品级接口）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章｜生产化：性能、更新、监控、成本与合规</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章｜LLM Toolcall & Agent：导航工具设计、澄清策略与可靠执行</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="2osm-odbl">第2章｜OSM 数据模型与 ODbL 合规（底层拓扑与法律边界）</h1>
<h2 id="21">2.1 开篇段落</h2>
<p>在开始下载和处理 TB 级别的 OSM 数据之前，必须纠正一个常见的认知偏差：<strong>OpenStreetMap 不是一张地图，而是一个没有任何图层概念的拓扑数据库</strong>。</p>
<p>当你看着 Google Maps 或高德地图时，你看到的是经过渲染的瓦片（Tile）；但当你作为开发者面对 OSM 时，你面对的是一个由数亿个节点和连线构成的巨型图（Graph）。对于导航 API 和 Navigation MCP 而言，视觉上的“路”没有任何意义，只有数据库中的“连通性”才决定了 LLM 能否规划出一条从 A 到 B 的合法路线。</p>
<p>本章将深入 OSM 的原子结构，揭示导航引擎（如 OSRM）是如何理解“路口”、“立交桥”和“禁止左转”的。同时，我们将详细拆解 ODbL 协议，特别是对于商业应用和 LLM Agent 场景，明确“数据使用”与“数据衍生”的界限，确保你的服务在合规的轨道上运行。</p>
<hr />
<h2 id="22-osm-the-primitives">2.2 OSM 的三大基本要素 (The Primitives)</h2>
<p>OSM 的数据模型极其精简，仅由三种原语（Primitives）构成。理解它们的相互引用关系是理解整个系统的关键。</p>
<h3 id="1-node">1. Node (节点) —— 空间锚点</h3>
<ul>
<li><strong>定义</strong>：地理空间的基础原子，由 <code>ID</code> (64-bit integer)、<code>Latitude</code> (纬度)、<code>Longitude</code> (经度) 组成。</li>
<li><strong>导航语义</strong>：</li>
<li><strong>几何支撑</strong>：定义道路弯曲的形状。</li>
<li><strong>拓扑连接点</strong>：当两个 Way 引用同一个 Node ID 时，导航引擎认为它们是物理连接的（即路口）。</li>
<li><strong>POI 载体</strong>：孤立的 Node 可以代表一个商店、红绿灯或公交站。</li>
</ul>
<h3 id="2-way">2. Way (路径/区域) —— 线性连接</h3>
<ul>
<li><strong>定义</strong>：由 2 到 2,000 个 Node ID 构成的<strong>有序列表</strong>。注意是引用”，Way 本身不存储坐标，只存储 Node ID 的序列。</li>
<li><strong>导航语义</strong>：</li>
<li><strong>方向性</strong>：Node 的存储顺序决定了 Way 的方向。这对 <code>oneway=yes</code>（单行道）至关重要。</li>
<li><strong>Open Way (线)</strong>：首尾 Node 不同。代表道路、河流、铁路。</li>
<li><strong>Closed Way (面)</strong>：首尾 Node ID 相同。代表环岛（Roundabout）、建筑物、公园。</li>
<li><strong>Polyline 甚至 Polygon</strong>：在 PostGIS 中，Open Way 映射为 <code>LineString</code>，Closed Way 视 Tag 不同映射为 <code>Polygon</code> 或 <code>LineString</code>（如环岛）。</li>
</ul>
<h3 id="3-relation">3. Relation (关系) —— 逻辑约束</h3>
<ul>
<li><strong>定义</strong>：最抽象也最强大的元素。它是一个有序列表，成员可以是 Node、Way 或其他 Relation。每个成员都有一个 <code>role</code> (角色) 字符串。</li>
<li><strong>导航语义</strong>：这是初学者最容易忽视的部分。</li>
<li><strong>转向限制 (Turn Restrictions)</strong>：定义“禁止左转”、“必须直行”。</li>
<li><strong>线路 (Route)</strong>：定义公交线、地铁线（由成百上千条 Way 组）。</li>
<li><strong>多边形 (Multipolygon)</strong>：带孔洞的建筑物或复杂的行政区边界。</li>
</ul>
<blockquote>
<p><strong>Rule of Thumb (拓扑第一定律)</strong>：
在 OSM 中，两条线在地图上视觉交叉（坐标重合）<strong>并不代表它们相交</strong>。只有当它们共享同一个 <strong>Node ID</strong> 时，导航引擎才认为它们是相通的。否则，这就是立体交叉（立交桥/隧道）。</p>
</blockquote>
<hr />
<h2 id="23-tags">2.3 深入 Tags：从文本到导航权重</h2>
<p>Tags 是附加在上述三个元素上的键值对（Key-Value）。导航引擎（OSRM/Valhalla）本质上就是一个<strong>将 Tags 映射为 Edge Weights（边权重）的编译器</strong>。</p>
<h3 id="tag">关键 Tag 解析</h3>
<h4 id="1-highway">1. 道路层级 (<code>highway=*</code>)</h4>
<p>这是决定路由偏好的核心。</p>
<ul>
<li><code>motorway</code> / <code>trunk</code>: 高速与快速路。通常隐含 <code>oneway=yes</code> 和高限速。</li>
<li><code>primary</code> / <code>secondary</code> / <code>tertiary</code>: 主干道到支路。</li>
<li><code>residential</code> / <code>service</code>: 居住区与内部道路（权重极低，非终点尽量不走）。</li>
<li><code>track</code> / <code>path</code>: 农径或小路（通常汽车不行）。</li>
</ul>
<h4 id="2-access">2. 通行权限 (<code>access=*</code>)</h4>
<p>这是决定“能不能走”的布尔开关。</p>
<ul>
<li><strong>默认值逻辑</strong>：如果没写 <code>access</code>，默认对所有模式开放（除非 <code>highway=motorway</code> 默认禁行人/骑行）。</li>
<li><strong>层级覆盖</strong>：<code>access=no</code> + <code>bus=yes</code> = 只有公交车能进。</li>
<li><strong>常见陷阱</strong>：<code>access=private</code> (私有道路，导航通常避开除非是终点)、<code>access=customers</code> (仅限顾客)。</li>
</ul>
<h4 id="3-oneway">3. 单行与方向 (<code>oneway=*</code>)</h4>
<ul>
<li><code>yes</code> / <code>1</code>: 仅允许沿 Node 序列正向通行。</li>
<li><code>-1</code>: 仅允许沿 Node 序列<strong>逆向</strong>通行。</li>
<li><code>reversible</code>: 潮汐车道（需要结合时间段，复杂处理）。</li>
</ul>
<h4 id="4">4. 物理限制</h4>
<ul>
<li><code>maxspeed=*</code>: 影响 ETA 计算。</li>
<li><code>maxheight=*</code> / <code>maxweight=*</code>: 卡车导航的命门。</li>
<li><code>width=*</code>: 狭窄道路避让。</li>
</ul>
<h3 id="ascii-tag">ASCII 图解：Tag 如何构建有向图</h3>
<div class="codehilite"><pre><span></span><code>       Node A (id:1)        Node B (id:2)         Node C (id:3)
          o--------------------o---------------------o

Scenario 1: 普通双向路
Way 1 (A-&gt;B-&gt;C): highway=residential
Graph Edge: A-&gt;B (cost:10), B-&gt;A (cost:10), B-&gt;C (cost:10), C-&gt;B (cost:10)

Scenario 2: 单行道
Way 1 (A-&gt;B-&gt;C): highway=primary, oneway=yes
Graph Edge: A-&gt;B (cost:5), B-&gt;C (cost:5)
(注意：B-&gt;A 和 C-&gt;B 的 Edge 不存在)

Scenario 3: 逆向单行道
Way 1 (A-&gt;B-&gt;C): highway=primary, oneway=-1
Graph Edge: C-&gt;B (cost:5), B-&gt;A (cost:5)
(注意：车辆实际行驶方向与 Node 存储顺序相反)
</code></pre></div>

<hr />
<h2 id="24-relation">2.4 复杂路口建模：Relation 的核心作用</h2>
<p>如果不处理 Relation，你的导航就会变成“违章指挥器”。最典型的场景是 <strong>Turn Restriction (转向限制)</strong>。</p>
<h3 id="typerestriction">数据结构：Type=restriction</h3>
<p>一个标准的禁止左转 Relation 包含三个成员：</p>
<ol>
<li><strong>from</strong> (Way ID): 车辆当前所在的道路。</li>
<li><strong>via</strong> (Node ID): 路口节点。</li>
<li><strong>to</strong> (Way ID): 车辆想要进入的道路。</li>
<li><strong>Tag</strong>: <code>restriction=no_left_turn</code> 或 <code>restriction=only_straight_on</code>。</li>
</ol>
<h3 id="ascii-relation">ASCII 演示：为什么需要 Relation</h3>
<div class="codehilite"><pre><span></span><code>      |   |
      | C | Way C (To)

      | C | Way C (To)
      |   |

------+   +-------
Way A   X   Way B
(From)+   +-------
      |   |
      | D |

      | D |
      |   |

车辆从 A 行驶到路口 X。
物理上：A 连接 B, C, D，看起来都能走。
逻辑上：
Relation (ID: 999):

  - type: restriction
  - from: Way A
  - via: Node X
  - to: Way C
  - restriction: no_left_turn

导航引擎解析：
在生成图时，生成 Edge (A-&gt;B), Edge (A-&gt;D)，但**显式删除** Edge (A-&gt;C) 或将其权重设为无限大。
</code></pre></div>

<blockquote>
<p><strong>进阶</strong>：如果是 <code>restriction:conditional = no_left_turn @ (07:00-09:00)</code>，这被称为<strong>时变限制</strong>。标准的 OSRM 处理不了这个（它需要预处理成静态图），需要使用 Valhalla 或 GraphHopper 这种支持动态 Costing 的引擎。</p>
</blockquote>
<hr />
<h2 id="25-odbl">2.5 ODbL 协议详解：合规的红线</h2>
<p>Open Database License (ODbL) 是悬在每个 OSM 开发者头上的达摩克利斯之剑。很多人因为害怕它而放弃 OSM。其实只要理清 <strong>Derivative Database (衍生库)</strong> 与 <strong>Produced Work (作品)</strong> 的区别，商业应用完全可行。</p>
<h3 id="1">1. 核心定义</h3>
<ul>
<li><strong>Derivative Database (衍生数据库)</strong>：如果你修改了 OSM 数据（修正坐标、添加属性），并且这个修改足以构成一个新的数据库。</li>
<li><strong>触发条件</strong>：将 OSM 数据与你的私有数据（如私有路网）进行<strong>物理融合</strong>或<strong>逻辑强绑定</strong>。</li>
<li>
<p><strong>义务</strong>：必须以 ODbL 协议公开这个新数据库（即“传染性”）。</p>
</li>
<li>
<p><strong>Produced Work (作品)</strong>：使用数据产生的输出。</p>
</li>
<li><strong>范畴</strong>：渲染出的地图图片（Tiles）、计算出的路径（Route Geometry）、地理编码返回的坐标（Lat/Lon）、文本指令。</li>
<li>
<p><strong>义务</strong>：仅需署名。<strong>不需要开源你的算法，也不需要开源生成的这些结果。</strong></p>
</li>
<li>
<p><strong>Collective Database (集合数据库)</strong>：将 OSM 与其他数据放在一起，但保持独立。</p>
</li>
<li><strong>范畴</strong>：你在 PostGIS 里建了两个 schema，一个放 <code>osm_roads</code>，一个放 <code>my_proprietary_pois</code>。它们各自独立更新，仅在询时 join。</li>
<li><strong>后果</strong>：这是安全的。私有数据不会被 ODbL 传染。</li>
</ul>
<h3 id="2">2. 常见场景判定表</h3>
<p>| 场景 | 属于分类 | 是否需要开源私有数据？ | 备注 |</p>
<table>
<thead>
<tr>
<th style="text-align: left;">场景</th>
<th style="text-align: left;">属于分类</th>
<th style="text-align: left;">是否需要开源私有数据？</th>
<th style="text-align: left;">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>场景 A</strong>：用 OSM 数据渲染地图瓦片，叠加自己采集的门店 POI 图层。</td>
<td style="text-align: left;">Produced Work (瓦片) + Collective DB (叠加)</td>
<td style="text-align: left;"><strong>否</strong></td>
<td style="text-align: left;">最常见的商业模式。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>场景 B</strong>：下载 OSM 路网，用算法修复了断头路，然后作为 API 出售路网文件。</td>
<td style="text-align: left;">Derivative Database</td>
<td style="text-align: left;"><strong>是</strong></td>
<td style="text-align: left;">你必须把修复后的路网开源。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>场景 C</strong>：用户请求导航，服务器用 OSM 算路，返回 JSON 给用户。</td>
<td style="text-align: left;">Produced Work</td>
<td style="text-align: left;"><strong>否</strong></td>
<td style="text-align: left;">你的路由算法和返回的 JSON 都是你的。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>场景 D</strong>：提取 OSM 建筑物轮廓，用来训练 AI 识别卫星图。</td>
<td style="text-align: left;">Produced Work (模型权重)</td>
<td style="text-align: left;"><strong>否</strong> (目前社区共识)</td>
<td style="text-align: left;">训练出的模型通常视为作品。</td>
</tr>
</tbody>
</table>
<h3 id="3-attribution">3. Attribution (署名) 具体要求</h3>
<p>ODbL 要求“合理的署名”对于 MCP Tool 和 Agent：</p>
<ul>
<li><strong>Tool Description</strong>: 在工具描述中注明 "Data from OpenStreetMap".</li>
<li><strong>Tool Output</strong>: 在 JSON 结果中包含 <code>attribution</code> 字段。</li>
<li><strong>UI</strong>: 如果有前端展示，必须在地图角落显示链接。</li>
</ul>
<hr />
<h2 id="26-id">2.6 数据版本与唯一标识符 (ID) 的易变性</h2>
<p>这是 OSM 开发中最容易踩的坑之一：<strong>不要持久化存储 OSM ID</strong>。</p>
<ul>
<li><strong>ID 不稳定</strong>：如果一个用户删除了 Way A 并重新画了一条一模一样的，新 Way 的 ID 会变化。</li>
<li><strong>操作原子性</strong>：如果一个 Way 被切割（例如中间加了个红绿灯），原来的 ID 可能保留给其中一段，另一段生成新 ID；或者旧 ID 消失，生成两个新 ID。</li>
<li><strong>应对策略</strong>：</li>
<li>如果你需要存储“某家店的位置”，存 <strong>Lat/Lon 坐标</strong>，不要存 <code>node_id</code>。</li>
<li>如果你需要存储“某条路”，存 <strong>OSM ID</strong> 仅作为临时缓存键值，并接受它随时可能失效（Latent Link）。定期（如每周）重新匹配。</li>
</ul>
<hr />
<h2 id="27-gotchas">2.7 常见的几何与拓扑陷阱 (Gotchas)</h2>
<p>在处理数据时，以下情况会导致导航引擎崩溃或产生幻觉：</p>
<ol>
<li>
<p><strong>非平面交叉 (Grade Separation)</strong>：</p>
<ul>
<li>两条路 Lat/Lon 相交，但没有共享 Node。</li>
<li><em>原因</em>：这是立交桥或隧道。</li>
<li><em>检查</em>：查看 <code>layer=*</code> 或 <code>bridge=*</code> / <code>tunnel=*</code> 标签，虽然这些主要用于渲染，但拓扑上主要看<strong>是否共享 Node</strong>。</li>
</ul>
</li>
<li>
<p><strong>区域 (Area) 陷阱</strong>：</p>
<ul>
<li>你想找“人民广场”，结果路由把你带到了广场边缘的一条线上。</li>
<li><em>原因</em>：OSM 中广场通常是一个 Closed Way (Polygon)。路由引擎通常只能吸附（Snap）到最近的 Edge 上。如果你没有计算 Polygon 的质心（Centroid）作为导航终点，结果可能很奇怪。</li>
</ul>
</li>
<li>
<p><strong>虚拟连接线 (Implied Connection)</strong>：</p>
<ul>
<li>有些数据中，道路在小区门口断开了，但实际能走。</li>
<li><em>原因</em>：OSM 是众包数据，质量参差不齐。</li>
<li><em>解决</em>：商业引擎通常会有“路网修”预处理步骤（Snap to nearest within 5 meters），但 OSRM 默认通过 Profile 也可以容忍一定误差，或者数据本身需要人工修复。</li>
</ul>
</li>
<li>
<p><strong>混合模式路径</strong>：</p>
<ul>
<li><code>highway=pedestrian</code> (步行街) 连接了 <code>highway=primary</code>。</li>
<li>汽车导航会在接口处断开，这是正确的。但如果这是唯一的入口（例如只能步行最后 50 米），你的 API 需要支持“多模态最后就在一公里”（Car -&gt; Walk）。</li>
</ul>
</li>
</ol>
<hr />
<h2 id="28">2.8 本章小结</h2>
<ol>
<li><strong>拓扑至上</strong>：Node 是连接点，Way 是连线，Relation 是规则。没有共享 Node 就不连通。</li>
<li><strong>Tag 决定权重</strong>：同样的几何形状，<code>highway</code> 和 <code>access</code> 标签决定了它是高速公路还是人行道。</li>
<li><strong>Relation 决定合法性</strong>：必须解析 Relation 才能处理转向限制，否则导航是非法的。</li>
<li><strong>ODbL 边界</strong>：输出结果（Route/Image）是安全的 Produced Work；混合并分发原始数据是危险的 Derivative Database。</li>
<li><strong>ID 易变</strong>：永远不把 OSM ID 当作永久主键，存坐标才是王道。</li>
</ol>
<hr />
<h2 id="29">2.9 练习题</h2>
<h3 id="_1">基础题</h3>
<ol>
<li><strong>数据解读</strong>：查找一个 <code>junction=roundabout</code> 的 Way。它的 <code>oneway</code> 标签通常是什么？如果没有写 <code>oneway</code>，根据 OSM 规范它隐含的方向是什么？</li>
<li><strong>连通性判断</strong>：<ul>
<li>Way A Nodes: <code>[101, 102, 103]</code></li>
<li>Way B Nodes: <code>[104, 105, 106]</code></li>
<li>Way C Nodes: <code>[102, 105]</code></li>
<li>问：从 Way A 能走到 Way B 吗？路径是什么？</li>
</ul>
</li>
<li><strong>Tag 优先级</strong>：一条路同时标记了 <code>highway=track</code> 和 <code>motor_vehicle=yes</code>。普通的家用轿车（Car Profile）通常会避开它吗？为什么？</li>
</ol>
<h3 id="thinking">挑战题 (Thinking)</h3>
<ol start="4">
<li><strong>复杂 Relation</strong>：有些禁止左转是“仅对卡车生效”的（<code>restriction:hgv = no_left_turn</code>）。设计一个简单的 JSON 结构来描述这个规则，以便你的 Navigation MCP 能够告诉 LLM “如果你开的是卡车，这里不能转”。</li>
<li><strong>Schema 设计</strong>：在 PostGIS 中，你该如何存储 <code>Closed Way</code>（比如一个建筑物）？是用 <code>LineString</code> 还是 <code>Polygon</code>？这对计算“我是否在建筑物内”有什么性能影响？</li>
<li><strong>合规思考</strong>：你的公司是一个外卖平台。你下载了 OSM 数据，然后让骑手在送餐过程中标记“这里其实有个门”或者“这条路其实不通”。<ul>
<li>场景 A：你把这些标记只用于优化自家骑手的路线调度。</li>
<li>场景 B：你在 App 地图上把这条路画了出来给用户看。</li>
<li>哪种场景触发 ODbL 的 Share-Alike？如何规避？</li>
</ul>
</li>
</ol>
<details>
<summary>点击展开提示 (Hint)</summary>
<ol>
<li>Roundabout 通常隐含 <code>oneway=yes</code>。行驶方向取决于国家（右侧通行国家为逆时针）。</li>
<li>能。A (102) -&gt; C (102 -&gt; 105) -&gt; B (105)。</li>
<li>会避开（权重惩罚），但不会视为“不可通行”。<code>track</code> 基础速度很慢，且路况默认很差，除非是唯一路径，否则路由算法倾向于绕路。</li>
<li>你需要解析 <code>restriction:conditional</code> 或特定的交通工具后缀。JSON 需包含 <code>conditions</code> 字段。</li>
<li>应存储为 <code>Polygon</code>（或 Geography 类型）。计算 <code>ST_Contains</code> 时，Polygon 效率远高于判断点是否在 LineString 围成的圈内。且 PostGIS 对 Closed Way 导入时通常默认处理为 Polygon。</li>
<li>场景 A 属于内部使用（Internal Use），通常不强制开源，但处于灰色地带（如果分发到了骑手手机端 app，可能被视为公开分发）。场景 B 属于公开展示 Produced Work（地图），但如果地图本身包含了你们私有修正的路网数据（Derivative DB），则风险极高。规避方法：将修改点作为 Overlay（覆盖层/补丁）存储，不直接修改 OSM 原始表，仅在内存路由图中动态应用权重调整（Edge Weight customization）。</li>
</ol>
</details>
            </article>
            
            <nav class="page-nav"><a href="chapter1.html" class="nav-link prev">← 第1章｜全景与快速上手（从 0 跑通一次 geocode + route）</a><a href="chapter3.html" class="nav-link next">第3章｜OSM 数据获取、裁剪与增量更新（构建可持续的数据管道） →</a></nav>
        </main>
    </div>
</body>
</html>